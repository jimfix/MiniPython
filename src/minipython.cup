import java_cup.runtime.*;

/*
   September 2015 - changed considerably to work with a limited Python syntax
                    (authors: Jeremy Cosel and James Fix)
 */

/* MiniPython3 parser for CUP.  
 * Copyright (C) 2015 Jeremy Cosel (jcosel@reed.edu)
 * Modified from the Java 1.2 parser for CUP which had this copyright:
 *    Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 *    This program is released under the terms of the GPL; see the file
 *    COPYING for more details.  There is NO WARRANTY on this code.
 */

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

/* Terminals */

terminal ASSIGN;                       // assignment keyword
terminal RETURN;
terminal LPAREN, RPAREN;
terminal LBRACE, RBRACE;
terminal LBRACK, RBRACK;               // array index or type annotation
//terminal DOT, LEFT, RIGHT;             // field selector
terminal COMMA, COLON;                 // separators
terminal IF, ELSE;                     // conditional statement keywords
terminal WHILE;                        // loop keyword
terminal DEF;                          // definition keyword
terminal PLUS, MINUS, MULT, DIV, MOD;  // arithmetic
terminal LT, GT, LEQ, GEQ;             // comparators
terminal EQ, NEQ;                      // equality
terminal AND, OR, NOT;                 // logical connectives

terminal java.lang.Number INT_LITERAL;
terminal java.lang.Boolean BOOL_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;     // names
terminal java.lang.String NONE_LITERAL;

/* Variables */

non terminal Program program;
non terminal Block block;
non terminal Defn definition;
non terminal DefnList definition_list;
non terminal Statement statement;
non terminal StateList statement_list;
non terminal Statement if_statement;
non terminal Statement while_statement;
non terminal Statement return_statement;
non terminal java.lang.String name;
non terminal Formals formals;
non terminal Expn expression;
non terminal ExpnList expression_list;
non terminal Assign assignment;
non terminal java.lang.String binop;
non terminal java.lang.String unop;
non terminal java.lang.String postfix;
non terminal Literal literal;

/* Precedences */

precedence left DEF;
precedence left COLON;
precedence left LBRACE, RBRACE;
precedence left LPAREN, RPAREN;
precedence left LBRACK, RBRACK;
precedence left ASSIGN, RETURN;
precedence left IF, ELSE, WHILE;
precedence left COMMA;
precedence nonassoc LT, GT, LEQ, GEQ, NEQ, EQ;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
//precedence left DOT, LEFT, RIGHT;
precedence left INT_LITERAL, BOOL_LITERAL, STRING_LITERAL, IDENTIFIER;


/* The Grammar Rules */

start with program;

program  ::= definition_list:dl block:b    {: RESULT = new Program(dl,b); :}
    |   block:b {: RESULT = new Program(b); :}
    ;

block ::= LBRACE statement_list:sl RBRACE {: RESULT = sl; :}
    ;

definition_list ::= definition:d definition_list:dl {: RESULT = new DefnList(d,dl); :}
    |   definition:d {: RESULT = new DefnList(d,null); :}
    ;

statement_list ::= statement:s statement_list:sl {: RESULT = new StateList(s,sl); :}
    |   statement:s {: RESULT = new StateList(s,null); :}
    ;

definition ::= DEF IDENTIFIER:f LPAREN RPAREN COLON block:b {: RESULT = new Defn(f,b); :}
    |   DEF IDENTIFIER:f LPAREN formals:xs RPAREN COLON block:b {: RESULT = new Defn(f,xs,b); :}
    ;

statement ::= assignment:as {: RESULT = as; :}
    |    IDENTIFIER:f LPAREN expression_list:el RPAREN {: RESULT = new Call(f,el); :}
    |    IDENTIFIER:f LPAREN RPAREN {: RESULT = new Call(f); :}
    |   if_statement:i {: RESULT = i; :}
    |   while_statement:w {: RESULT = w; :}
    |   return_statement:r {: RESULT = r; :}
//    |   expression:exp {: RESULT = new Assign("it",exp); :}
    ;

assignment ::= name:n ASSIGN expression:exp {: RESULT = new Assign(n,exp); :}
    ;

if_statement ::= IF expression:exp COLON block:b {: RESULT = new If(exp,b); :}
    |  IF expression:exp COLON block:b1 ELSE COLON block:b2 {: RESULT = new If(exp,b1,b2); :}
    ;

while_statement ::= WHILE expression:exp COLON block:b {: RESULT = new While(exp,b); :}
    ;

return_statement ::= RETURN expression:exp {: RESULT = new Return(exp); :}
    |   RETURN {: RESULT = new Return(); :}
    ;

expression_list ::= expression:exp expression_list:el {: RESULT = new ExpnList(exp,el); :}
    |    expression:exp {: RESULT = new ExpnList(exp,null); :}
    ;

expression ::= expression:e1 binop:by expression:e2 {: RESULT = new Binop(e1,by,e2); :}
    |   unop:on expression:exp {: RESULT = new Unop(on,exp); :}
    |   name:n {: RESULT = new Lookup(n); :}
    |   literal:l {: RESULT = l; :}
    |   LPAREN expression:exp RPAREN {: RESULT = exp; :}
    |   IDENTIFIER:f LPAREN expression_list:el RPAREN {: RESULT = new Call(f,el); :}
    |   IDENTIFIER:f LPAREN RPAREN {: RESULT = new Call(f); :}
    ;

/* FunCall & ProCall */

binop ::= AND {: RESULT = "AND"; :}
    |   OR {: RESULT = "OR"; :}
    |   PLUS {: RESULT = "PLUS"; :}
    |   MINUS {: RESULT = "MINUS"; :}
    |   MULT {: RESULT = "MULT"; :}
    |   DIV {: RESULT = "DIV"; :}
    |   MOD {: RESULT = "MOD"; :}
    |   LT {: RESULT = "LT"; :}
    |   GT {: RESULT = "GT"; :}
    |   EQ {: RESULT = "EQ"; :}
    |   NEQ {: RESULT = "NEQ"; :}
    |   GEQ {: RESULT = "GEQ"; :}
    |   LEQ {: RESULT = "LEQ"; :}
    ;

unop ::= NOT:n {: RESULT = n.toString(); :}
//    |   MINUS:m {: RESULT = m.toString(); :}
    ;

formals ::= IDENTIFIER:x {: RESULT = new Formals(x); :}
    |    IDENTIFIER:x COMMA formals:xs {: RESULT = new Formals(x,xs); :}
    ;

name ::= IDENTIFIER:n {: RESULT = new Formals(n); :}
//    |  name:n postfix:post {: RESULT = new Name(n,post); :}
    ;
/*
postfix ::= DOT:dot LEFT:l
    |   DOT:dot RIGHT:r
    ;
*/

literal ::=  INT_LITERAL:i {: RESULT = new Literal(i.intValue()); :}
    |  BOOL_LITERAL:b {: RESULT = new Literal(b.booleanValue()); :}
    |  STRING_LITERAL:s {: RESULT = new Literal(s); :}
    |  NONE_LITERAL:none {: RESULT = new Literal(none); :}
    ;
