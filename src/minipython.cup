import java_cup.runtime.*;

/*
   September 2015 - changed considerably to work with a limited Python syntax
                    (authors: Jeremy Cosel and James Fix)
 */

/* MiniPython3 parser for CUP.  
 * Copyright (C) 2015 Jeremy Cosel (jcosel@reed.edu)
 * Modified from the Java 1.2 parser for CUP which had this copyright:
 *    Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 *    This program is released under the terms of the GPL; see the file
 *    COPYING for more details.  There is NO WARRANTY on this code.
 */

parser code  {: 
  public void report_error(String message, Object info) {
    StringBuilder m = new StringBuilder("Error ");

    if (info instanceof java_cup.runtime.Symbol) 
      m.append( "("+info.toString()+")" );
     
    m.append(" : "+message);
   
    System.out.println(m);
  }
   
  public void report_fatal_error(String message, Object info) {
    report_error(message, info);
    throw new RuntimeException("Fatal Syntax Error");
  }
:};

/* Terminals */

terminal ASSIGN;                       // assignment keyword
terminal RETURN;
terminal LPAREN, RPAREN;
terminal LBRACE, RBRACE;
terminal LBRACK, RBRACK;               // array index or type annotation
//terminal DOT, LEFT, RIGHT;                          // field selector
terminal COMMA, COLON;      // separators
terminal IF, ELSE;                     // conditional statement keywords
terminal WHILE;                        // loop keyword
terminal DEF;                          // definition keyword
terminal PLUS, MINUS, MULT, DIV, MOD;  // arithmetic
terminal LT, GT, LEQ, GEQ;             // comparators
terminal EQ, NEQ;                      // equality
terminal AND, OR, NOT;                 // logical connectives

terminal java.lang.Number INT_LITERAL;
terminal java.lang.Boolean BOOL_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;     // names
terminal NONE_LITERAL;

/* Variables */

non terminal program;
non terminal block;
non terminal definition, definition_list;
non terminal statement, statement_list;
non terminal if_statement, while_statement;
non terminal return_statement;
non terminal name;
non terminal formals;
non terminal expression, expression_list;
non terminal assignment;
non terminal binop;
non terminal unop;
//non terminal postfix;
non terminal literal;

/* Precedences */

precedence left DEF;
precedence left COLON;
precedence left LBRACE, RBRACE;
precedence left LPAREN, RPAREN;
precedence left LBRACK, RBRACK;
precedence left ASSIGN, RETURN;
precedence left IF, ELSE, WHILE;
precedence left COMMA;
precedence nonassoc LT, GT, LEQ, GEQ, NEQ, EQ;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD;
//precedence left DOT, LEFT, RIGHT;
precedence left INT_LITERAL, BOOL_LITERAL, STRING_LITERAL, IDENTIFIER, NONE_LITERAL;


/* The Grammar Rules */

start with program;

program  ::= definition_list:dl block:b    {: RESULT = new Program(dl,b); :}
    |   block {: RESULT = new Program(b); :}
    ;

block ::= LBRACE RBRACE {: RESULT = null; :}
    |   LBRACE statement_list:sl RBRACE {: RESULT = sl; :}
    ;

definition_list ::= definition:d definition_list:dl {: RESULT = new DefnList(d,dl); :}
    |   definition:d {: RESULT = d; :}
    ;

statement_list ::= statement:s statement_list:sl {: RESULT = new StateList(s,sl); :}
    |   statement {: RESULT = s; :}
    ;

definition ::= DEF IDENTIFIER:f LPAREN RPAREN COLON block:b {: RESULT = new Defn(f,b); :}
    |   DEF IDENTIFIER:f LPAREN formals:xs RPAREN COLON block:b {: RESULT = new Defn(f,xs,b,); :}
    ;

statement ::= assignment:assign {: RESULT = assign; :}
    |    IDENTIFIER:f LPAREN expression_list:el RPAREN {: RESULT = new Call(f,el); :}
    |    IDENTIFIER:f LPAREN RPAREN {: RESULT = New Call(f); :}
    |   if_statement:if {: RESULT = if; :}
    |   while_statement:while {: RESULT = while; :}
    |   return_statement:return {: RESULT = return; :}
    |   expression:exp {: RESULT = exp; :}
    ;

assignment ::= name:n ASSIGN expression:exp {: RESULT = new Assign(n,exp); :}
    ;

if_statement ::= IF expression:exp COLON block:b {: RESULT = new If(exp,b); :}
    |  IF expression COLON block:b1 ELSE COLON block:b2 {: RESULT = If(exp,b1,b2); :}
    ;

while_statement ::= WHILE expression:exp COLON block:b {: RESULT = new While(exp,b); :}
    ;

return_statement ::= RETURN expression:exp {: RESULT = new Return(exp); :}
    |   RETURN {: RESULT = new Return(); :}
    ;

expression_list ::= expression:exp expression_list:el {: RESULT = new ExpnList(exp,el); :}
    |    expression:exp {: RESULT = exp; :}
    ;

expression ::= expression:e1 binop:by expression:e2 {: RESULT = new Binop(e1,by,e2); :}
    |   unop:on expression:exp {: RESULT = new Unop(on,exp); :}
    |   name:n {: RESULT = n; :}
    |   literal:l {: RESULT = l; :}
//    |   LPAREN expression:exp RPAREN {: RESULT = exp; :}
//    |   IDENTIFIER:f LPAREN expression_list:el RPAREN {: RESULT = new Call(f,el); :}
//    |   IDENTIFIER:f LPAREN RPAREN {: RESULT = new Call(f); :}
    ;

binop ::= AND:and {: RESULT = and.toString(); :}
    |   OR:or {: RESULT = or.toString(); :}
    |   PLUS:plus {: RESULT = plus.toString(); :}
    |   MINUS:minus {: RESULT = minus.toString(); :}
    |   MULT:mult {: RESULT = mult.toString(); :}
    |   DIV:div {: RESULT = div.toString(); :}
    |   MOD:mod {: RESULT = mod.toString(); :}
    |   LT:lt {: RESULT = lt.toString(); :}
    |   GT:gt {: RESULT = gt.toString(); :}
    |   EQ:eq {: RESULT = eq.toString(); :}
    |   NEQ:neq {: RESULT = neq.toString(); :}
    |   GEQ:geq {: RESULT = geq.toString(); :}
    |   LEQ:leq {: RESULT = leq.toString(); :}
    ;

unop ::= MINUS:minus {: RESULT = minus.toString(); :}
    |   NOT:not {: RESULT = not.toString(); :}
    ;

formals ::= IDENTIFIER:x {: RESULT = new Formals(x); :}
    |    IDENTIFIER:x COMMA formals:xs {: RESULT = new Formals(x,xs); :}
    ;

name ::= IDENTIFIER:n {: RESULT = n.toString(); :}
//    |  name:n postfix:post {: RESULT = new Name(n,post); :}
    ;

/* postfix ::= DOT:dot LEFT:l
    |   DOT:dot RIGHT:r
    ;
*/

literal ::=  INT_LITERAL:int {: RESULT = new Literal(int.intValue(); :}
    |  BOOL_LITERAL:bool {: RESULT = new Literal(bool.booleanValue(); :}
    |  STRING_LITERAL:string {: RESULT = new Literal(string); :}
    |  NONE_LITERAL:none {: RESULT = new Literal(none); :}
    ;
