package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/*
   September 2015 - changed considerably to work with a limited Python syntax
                    (authors: Jeremy Cosel and James Fix)
 */

/* MiniPython3 parser for CUP.  
 * Copyright (C) 2015 Jeremy Cosel (jcosel@reed.edu)
 * Modified from the Java 1.2 parser for CUP which had this copyright:
 *    Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 *    This program is released under the terms of the GPL; see the file
 *    COPYING for more details.  There is NO WARRANTY on this code.
 */

parser code  {:
  /* Override default error message routine to handle line numbers correctly */
  /* This routine is also called in the process of handling fatal errors. */

  /** Report a non fatal error (or warning).  This method takes a message 
   *  string and an additional object (to be used by specializations 
   *  implemented in subclasses).  Prints the same simple error message
   *  as the base class version, but correctly labels the line number.
   *
   * @param message an error message.
   * @param info    an extra object reserved for use by specialized subclasses.
   */
  public void report_error(String message, Object info)
    {
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
    if (((Symbol)info).left != -1)
      System.err.println(" at line " + ((Symbol)info).left +
                 " of input");
    else System.err.println("");
      else System.err.println("");
    }
:};

/* Terminals */

terminal ASSIGN;                     // assignment keyword
terminal PRINT;
terminal LPAREN, RPAREN;
terminal LBRACE, RBRACE;
terminal LBRACK, RBRACK;               // array index or type annotation
//terminal DOT, LEFT, RIGHT;             // field selector
terminal COMMA, COLON;                 // separators
terminal IF, ELSE;                     // conditional statement keywords
terminal WHILE;                        // loop keyword
terminal DEF;                          // definition keyword
terminal PLUS, MINUS, TIMES/*, DIV, MOD*/;  // arithmetic
terminal LT/*, GT, LEQ, GEQ*/;             // comparators
//terminal EQ, NEQ;                        // equality
terminal AND,/* OR, */NOT;                 // logical connectives

terminal java.lang.Integer INT_LITERAL;
terminal java.lang.Boolean BOOL_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal Identifier IDENTIFIER;
terminal java.lang.String NONE_LITERAL;

/* Variables */

nonterminal AST.Program program;
nonterminal AST.Block block;
nonterminal AST.Defn definition;
nonterminal AST.DefnList definition_list;
nonterminal AST.Statement statement;
nonterminal AST.StatementList statement_list;
nonterminal AST.If if_statement;
nonterminal AST.While while_statement;
nonterminal AST.Print print_statement;
nonterminal AST.Identifier name;
nonterminal AST.FormalList formals;
nonterminal AST.Exp expression;
nonterminal AST.ExpList expression_list;
nonterminal AST.Assign assignment;
//nonterminal java.lang.String postfix;
nonterminal AST.IntegerLiteral int_literal;
nonterminal bool_literal;
nonterminal string_literal;

/* Precedences */

precedence left DEF;
precedence left COLON;
precedence left LBRACE, RBRACE;
precedence left LPAREN, RPAREN;
precedence left LBRACK, RBRACK;
precedence left ASSIGN/*, RETURN*/;
precedence left IF, ELSE, WHILE;
precedence left COMMA;
precedence nonassoc LT/*, GT, LEQ, GEQ, NEQ, EQ*/;
//precedence left OR;
precedence left AND;
precedence left NOT;
precedence left PLUS, MINUS;
precedence left TIMES/*, DIV, MOD*/;
//precedence left DOT, LEFT, RIGHT;
precedence left INT_LITERAL, BOOL_LITERAL, STRING_LITERAL, IDENTIFIER;


/* The Grammar Rules */

start with program;

program  ::= definition_list:dl block:b    {: RESULT = new Program(dl,b,dlleft); :}
    |   block:b {: RESULT = new Program(new DefnList(bleft),b,bleft); :}
    ;

block ::= LBRACE:l statement_list:sl RBRACE {: RESULT = new Block(sl,lleft); :}
    ;

definition_list ::= definition:d {: DefnList dl = new DefnList(dleft); dl.add(d); RESULT = dl; :}
    |   definition_list:dl definition:d {: dl.add(d); RESULT = dl; :}
    ;

statement_list ::= statement:s {: StatementList sl = new StatementList(sleft); sl.add(s); RESULT = sl; :}
    |   statement_list:sl statement:s {: sl.add(s); RESULT = sl; :}
    ;

definition ::= DEF:df IDENTIFIER:f LPAREN RPAREN COLON block:b {: RESULT = new Defn(null,f,null,null,b,null,dfleft); :}
    |   DEF:df IDENTIFIER:f LPAREN formals:xs RPAREN COLON block:b {: RESULT = new Defn(null,f,xs,null,b,null,dfleft); :}
    ;

statement ::= assignment:as {: RESULT = as; :}
    |   if_statement:i {: RESULT = i; :}
    |   while_statement:w {: RESULT = w; :}
    |   print_statement:p {: RESULT = p; :}
    |   expression:exp {: RESULT = exp; :}
    ;

assignment ::= name:n ASSIGN expression:exp {: RESULT = new Assign(n,exp,nleft); :}
    ;

if_statement ::= IF:i expression:exp COLON block:b {: RESULT = new If(exp,b,null,ileft); :}
    |  IF:i expression:exp COLON block:b1 ELSE COLON block:b2 {: RESULT = new If(exp,b1,b2,ileft); :}
    ;

while_statement ::= WHILE:wh expression:exp COLON block:b {: RESULT = new While(exp,b,whleft); :}
    ;

print_statement ::= PRINT:pr expression:exp {: RESULT = new Print(exp,prleft); :}
    ;

expression_list ::= expression:exp {: ExpList el = new ExpList(expleft); el.add(exp); RESULT = el; :}
    |    expression_list:el expression:exp {: el.add(exp); RESULT = el; :}
    ;

expression ::= expression:e1 PLUS expression:e2 {: RESULT = new Plus(e1,e2,e1left); :}
    |   expression:e1 MINUS expression:e2 {: RESULT = new Minus(e1,e2,e1left); :}
    |   expression:e1 TIMES expression:e2 {: RESULT = new Times(e1,e2,e1left); :}
    |   expression:e1 AND expression:e2 {: RESULT = new And(e1,e2,e1left); :}
    |   expression:e1 LT expression:e2 {: RESULT = new LessThan(e1,e2,e1left); :}
    |   NOT:not expression:e {: RESULT = new Not(e,notleft); :}
    |   name:n {: RESULT = new Name(null,n,nleft); :}
    |   int_literal:i {: RESULT = i; :}
//    |   bool_literal:b {: RESULT = b; :}
//    |   string_literal:s {: RESULT = s; :}
    |   LPAREN expression:exp RPAREN {: RESULT = exp; :}
    |   IDENTIFIER:f LPAREN expression_list:el RPAREN {: RESULT = new Call(null,f,el,fleft); :}
    |   IDENTIFIER:f LPAREN RPAREN {: RESULT = new Call(null,f,new ExpList(fleft),fleft); :}
    ;

/*binop ::=
    |   OR {: RESULT = "OR"; :}
    |   DIV {: RESULT = "DIV"; :}
    |   MOD {: RESULT = "MOD"; :}
    |   GT {: RESULT = "GT"; :}
    |   EQ {: RESULT = "EQ"; :}
    |   NEQ {: RESULT = "NEQ"; :}
    |   GEQ {: RESULT = "GEQ"; :}
    |   LEQ {: RESULT = "LEQ"; :}
    ;
*/

formals ::= IDENTIFIER:x {: FormalList fl = new FormalList(xleft); fl.add(new Formal(null,x,xleft)); RESULT = fl; :}
    |    formals:fl COMMA IDENTIFIER:x {: fl.add(new Formal(null,x,flleft)); RESULT = fl; :}
    ;

name ::= IDENTIFIER:n {: new IdentifierExp(n.toString(),nleft); :}
//    |  name:n postfix:post {: RESULT = new Name(n,post,nleft); :}
    ;
/*
postfix ::= DOT:dot LEFT:l
    |   DOT:dot RIGHT:r
    ;
*/

int_literal ::=  INT_LITERAL:i {: RESULT = new IntegerLiteral(i,ileft); :}
    ;
//bool_literal ::= BOOL_LITERAL:b {: RESULT = b.toString(); :}
//    ;
//string_literal ::= STRING_LITERAL:s {: RESULT = s.toString(); :}
//    ;
//NONE_LITERAL:none {: RESULT = none.toString(); :}
