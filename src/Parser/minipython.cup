package Parser;

import AST.*;
import java.util.*;
import java_cup.runtime.*;

/*
   September 2015 - changed considerably to work with a limited Python syntax
                    (authors: Jeremy Cosel and James Fix)
 */

/* MiniPython3 parser for CUP.  
 * Copyright (C) 2015 Jeremy Cosel (jcosel@reed.edu)
 * Modified from the Java 1.2 parser for CUP which had this copyright:
 *    Copyright (C) 1998 C. Scott Ananian <cananian@alumni.princeton.edu>
 *    This program is released under the terms of the GPL; see the file
 *    COPYING for more details.  There is NO WARRANTY on this code.
 */

parser code  {:
  /* Override default error message routine to handle line numbers correctly */
  /* This routine is also called in the process of handling fatal errors. */

  /** Report a non fatal error (or warning).  This method takes a message 
   *  string and an additional object (to be used by specializations 
   *  implemented in subclasses).  Prints the same simple error message
   *  as the base class version, but correctly labels the line number.
   *
   * @param message an error message.
   * @param info    an extra object reserved for use by specialized subclasses.
   */
  public void report_error(String message, Object info)
    {
      System.err.print(message);
      System.err.flush();
      if (info instanceof Symbol)
    if (((Symbol)info).left != -1)
      System.err.println(" at line " + ((Symbol)info).left +
                 " of input");
    else System.err.println("");
      else System.err.println("");
    }
:};

/* Terminals */

terminal java.lang.String ASSIGN;                     // assignment keyword
terminal java.lang.String PRINT, RETURN;
terminal java.lang.String LPAREN, RPAREN;
terminal java.lang.String LBRACE, RBRACE;
//terminal LBRACK, RBRACK;               // array index or type annotation
//terminal DOT, LEFT, RIGHT;             // field selector
terminal java.lang.String COMMA, COLON;                 // separators
terminal java.lang.String IF, ELSE;                     // conditional statement keywords
terminal java.lang.String WHILE;                        // loop keyword
terminal java.lang.String DEF;                          // definition keyword
terminal java.lang.String PLUS, MINUS, TIMES, DIV, MOD;  // arithmetic
terminal java.lang.String LT, GT, LEQ, GEQ;             // comparators
terminal java.lang.String EQ, NEQ;                        // equality
terminal java.lang.String AND, OR, NOT;                 // logical connectives

terminal java.lang.Integer INT_LITERAL;
terminal java.lang.Boolean BOOL_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String IDENTIFIER;
//terminal java.lang.String NONE_LITERAL;

/* Variables */

nonterminal AST.Program program;
nonterminal AST.Block block;
nonterminal AST.Defn definition;
nonterminal AST.DefnList definition_list;
nonterminal AST.Statement statement;
nonterminal AST.StatementList statement_list;
nonterminal AST.If if_statement;
nonterminal AST.While while_statement;
nonterminal AST.Print print_statement;
nonterminal AST.FormalList formals;
nonterminal AST.Exp expression;
nonterminal AST.ExpList expression_list;
nonterminal AST.Assign assignment;
//nonterminal java.lang.String postfix;

/* Precedences */

precedence left DEF;
precedence left COLON;
precedence left LBRACE, RBRACE;
precedence left LPAREN, RPAREN;
//precedence left LBRACK, RBRACK;
precedence left ASSIGN/*, RETURN*/;
precedence left IF, ELSE, WHILE;
precedence left COMMA;
precedence nonassoc LT, GT, LEQ, GEQ, NEQ, EQ;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, MOD;
//precedence left DOT, LEFT, RIGHT;
precedence left INT_LITERAL,/*BOOL_LITERAL*/ STRING_LITERAL, IDENTIFIER;


/* The Grammar Rules */

start with program;

program  ::= definition_list:dl block:b    {: RESULT = new Program(dl,b,dlleft); :}
    |   block:b {: RESULT = new Program(new DefnList(bleft),b,bleft); :}
    ;

block ::= LBRACE:l statement_list:sl RBRACE {: RESULT = new Block(sl,lleft); :}
    ;

definition_list ::= definition:d {: DefnList dl = new DefnList(dleft); dl.add(d); RESULT = dl; :}
    |   definition_list:dl definition:d {: dl.add(d); RESULT = dl; :}
    ;

statement_list ::= statement:s {: StatementList sl = new StatementList(sleft); sl.add(s); RESULT = sl; :}
    |   statement_list:sl statement:s {: sl.add(s); RESULT = sl; :}
    ;

definition ::= DEF:df IDENTIFIER:f LPAREN RPAREN COLON block:b RETURN expression:exp {: RESULT = new Defn(null,new Identifier(f,dfleft),null,b,exp,dfleft); :}
    |   DEF:df IDENTIFIER:f LPAREN formals:xs RPAREN COLON block:b RETURN expression:exp {: RESULT = new Defn(null,new Identifier(f,dfleft),xs,b,exp,dfleft); :}
    ;

statement ::= assignment:as {: RESULT = as; :}
    |   if_statement:i {: RESULT = i; :}
    |   while_statement:w {: RESULT = w; :}
    |   print_statement:p {: RESULT = p; :}
    |   expression:exp {: RESULT = new Assign(new Identifier("_",expleft),exp,expleft); :}
    ;

assignment ::= IDENTIFIER:i ASSIGN expression:exp {: RESULT = new Assign(new Identifier(i,ileft),exp,ileft); :}
    ;

if_statement ::= IF:i expression:exp COLON block:b {: RESULT = new If(exp,b,null,ileft); :}
    |  IF:i expression:exp COLON block:b1 ELSE COLON block:b2 {: RESULT = new If(exp,b1,b2,ileft); :}
    ;

while_statement ::= WHILE:wh expression:exp COLON block:b {: RESULT = new While(exp,b,whleft); :}
    ;

print_statement ::= PRINT:pr expression:exp {: RESULT = new Print(exp,prleft); :}
    ;

expression_list ::= expression:exp {: ExpList el = new ExpList(expleft); el.add(exp); RESULT = el; :}
    |    expression_list:el expression:exp {: el.add(exp); RESULT = el; :}
    ;

expression ::= expression:e1 PLUS expression:e2 {: RESULT = new Plus(e1,e2,e1left); :}
    |   expression:e1 MINUS expression:e2 {: RESULT = new Minus(e1,e2,e1left); :}
    |   expression:e1 TIMES expression:e2 {: RESULT = new Times(e1,e2,e1left); :}
    |   expression:e1 DIV expression:e2 {: RESULT = new Div(e1,e2,e1left); :}
    |   expression:e1 MOD expression:e2 {: RESULT = new Mod(e1,e2,e1left); :}    
    |   expression:e1 AND expression:e2 {: RESULT = new And(e1,e2,e1left); :}
    |   expression:e1 OR expression:e2 {: RESULT = new Or(e1,e2,e1left); :}    
    |   expression:e1 GT expression:e2 {: RESULT = new GreaterThan(e1,e2,e1left); :}
    |   expression:e1 LT expression:e2 {: RESULT = new LessThan(e1,e2,e1left); :}
    |   expression:e1 EQ expression:e2 {: RESULT = new Equals(e1,e2,e1left); :}
    |   expression:e1 NEQ expression:e2 {: RESULT = new NotEquals(e1,e2,e1left); :}
    |   expression:e1 GEQ expression:e2 {: RESULT = new GreaterEquals(e1,e2,e1left); :}
    |   expression:e1 LEQ expression:e2 {: RESULT = new LessEquals(e1,e2,e1left); :}
    |   NOT:not expression:e {: RESULT = new Not(e,notleft); :}
    |   INT_LITERAL:i {: RESULT = new IntegerLiteral(i,ileft); :}
    |   BOOL_LITERAL:b {: RESULT = new BooleanLiteral(b,bleft); :}
    |   LPAREN expression:exp RPAREN {: RESULT = exp; :}
    |   IDENTIFIER:f LPAREN expression_list:el RPAREN {: RESULT = new Call(null,new Identifier(f,fleft),el,fleft); :}
    |   STRING_LITERAL:f {: RESULT = new IdentifierExp(f,fleft); :}
//    |  name:n postfix:post {: RESULT = new Name(n,post,nleft); :}
    ;

formals ::= IDENTIFIER:x {: FormalList fl = new FormalList(xleft); fl.add(new Formal(null,new Identifier(x,xleft),xleft)); RESULT = fl; :}
    |    formals:fl COMMA IDENTIFIER:x {: fl.add(new Formal(null,new Identifier(x,flleft),flleft)); RESULT = fl; :}
    ;

/*
postfix ::= DOT:dot LEFT:l
    |   DOT:dot RIGHT:r
    ;


NONE_LITERAL:none {: RESULT = none.toString(); :}
  ;
*/
